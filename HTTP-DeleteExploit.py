import requests
from colorama import Fore, init
import warnings
from urllib3.exceptions import InsecureRequestWarning
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

# Disable SSL warnings
warnings.filterwarnings("ignore", category=InsecureRequestWarning)

# Initialize colorama
init(autoreset=True)

# Display banner
print("──────────────────────────────────────────────")
print("  Script name : HTTP-DeleteExploit ")
print("  Script by Mohammad Radmehr")
print("  Contact: Telegram = t.me/CBL_209")
print("  Cybersecurity expert with a focus on web penetration testing")
print("  vulnerability assessment, and comprehensive reporting to strengthen")
print("  the security of web-based systems.")
print("──────────────────────────────────────────────")

def check_if_deleted(url, endpoint, verify_ssl):
    """
    Checks if the resource was deleted by sending a GET request.
    Args:
        url (str): Base URL of the target server.
        endpoint (str): Endpoint to check.
        verify_ssl (bool): Whether to verify SSL certificate.
    Returns:
        bool: True if resource is deleted (404 status), False otherwise.
    """
    if not endpoint.startswith('/'):
        endpoint = '/' + endpoint
    full_url = f"{url.rstrip('/')}{endpoint}"

    try:
        response = requests.get(full_url, verify=verify_ssl)
        if response.status_code == 404:
            return True  # Resource deleted
        else:
            return False  # Resource still exists
    except requests.exceptions.RequestException as e:
        print(Fore.RED + f"[!] Error checking {full_url}: {e}")
        return False

def test_delete_method(url, endpoint, verify_ssl):
    """
    Tests DELETE method on a server by sending requests to specific endpoint and checking if the resource is deleted.
    Args:
        url (str): Base URL of the target server.
        endpoint (str): Endpoint to test.
        verify_ssl (bool): Whether to verify SSL certificate.
    Returns:
        str: Result of the DELETE request test for the endpoint.
    """
    if not endpoint.startswith('/'):
        endpoint = '/' + endpoint
    full_url = f"{url.rstrip('/')}{endpoint}"
    
    try:
        response = requests.delete(full_url, verify=verify_ssl)
        if response.status_code in [200, 202, 204]:
            print(f"{Fore.BLUE}[+] DELETE succeeded on {full_url} (Status Code: {response.status_code})")
            
            # Check if resource is really deleted
            if check_if_deleted(url, endpoint, verify_ssl):
                return f"{Fore.GREEN}[+] Resource confirmed deleted: {full_url}"
            else:
                return f"{Fore.YELLOW}[-] Resource still exists: {full_url}"
        elif response.status_code in [401, 403]:
            return f"{Fore.RED}[-] Access denied: Authentication required for {full_url} (Status Code: {response.status_code})"
        else:
            return f"{Fore.RED}[-] Not vulnerable: DELETE not allowed on {full_url} (Status Code: {response.status_code})"
    except requests.exceptions.RequestException as e:
        return f"{Fore.RED}[!] Error testing {full_url}: {e}"

def test_endpoints_parallel(url, endpoints, verify_ssl):
    """
    Tests DELETE method concurrently on multiple endpoints.
    Args:
        url (str): Base URL of the target server.
        endpoints (list): List of endpoints to test.
        verify_ssl (bool): Whether to verify SSL certificate.
    Returns:
        None
    """
    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = {executor.submit(test_delete_method, url, endpoint, verify_ssl): endpoint for endpoint in endpoints}
        for future in as_completed(futures):
            print(future.result())

if __name__ == "__main__":
    # Get target server URL from user
    target_url = input("Enter the target server URL (e.g., http://example.com): ").strip()

    # Ask user whether to verify SSL certificate
    print("Do you want to verify SSL certificates? (1 for Yes, 2 for No)")
    ssl_choice = input("Enter 1 to enable SSL verification or 2 to disable it: ").strip()

    # Set SSL verification based on user input
    verify_ssl = ssl_choice == '1'
    if verify_ssl:
        print(Fore.BLUE + "SSL verification is enabled.")
    else:
        print(Fore.RED + "SSL verification is disabled.")

    # Get endpoints from user
    print("Do you have one or multiple endpoints? (Enter '1' for one, '2' for multiple):")
    endpoints_choice = input().strip()

    if endpoints_choice == '1':
        endpoint = input("Enter the endpoint to test (e.g., api/users/123): ").strip()
        test_endpoints = [endpoint]
    elif endpoints_choice == '2':
        file_path = input("Enter the path to the .txt file containing the endpoints: ").strip()
        try:
            with open(file_path, 'r') as file:
                test_endpoints = [line.strip() for line in file.readlines()]
            print(Fore.BLUE + f"Loaded endpoints from {file_path}")
        except FileNotFoundError:
            print(Fore.RED + f"Error: File {file_path} not found. Exiting.")
            exit(1)
    else:
        print(Fore.RED + "Invalid input. Exiting.")
        exit(1)

    if not test_endpoints:
        print(Fore.RED + "No endpoints provided. Exiting.")
    else:
        start_time = time.time()
        test_endpoints_parallel(target_url, test_endpoints, verify_ssl)
        end_time = time.time()
        print(Fore.GREEN + f"Test completed in {end_time - start_time:.2f} seconds.")
